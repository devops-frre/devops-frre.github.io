{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Bienvenidos El objetivo de este sitio es brindar una experiencia mas flexible y agradable a los estudiantes en las clases pr\u00e1cticas de la c\u00e1tedra DevOps.","title":"Bienvenido"},{"location":"#bienvenidos","text":"El objetivo de este sitio es brindar una experiencia mas flexible y agradable a los estudiantes en las clases pr\u00e1cticas de la c\u00e1tedra DevOps.","title":"Bienvenidos"},{"location":"contenido/","text":"Contenido Unidad Tem\u00e1tica 1: Introducci\u00f3n a DevOps Objetivos espec\u00edficos: Que el alumno comprenda cu\u00e1les son los desaf\u00edos actuales que enfrenta la gesti\u00f3n completa del ciclo de vida de las aplicaciones, y la relaci\u00f3n de estos con el \u00e1rea de operaciones de TI. Que el alumno conozca cu\u00e1les son las expectativas de las empresas y el mercado del rol de responsable o miembro de un \u00e1rea de DevOps. Contenidos: \u00bfQu\u00e9 es DevOps? Antecedentes. Historia. Objetivos. El desarrollo \u00e1gil de software y DEVOPS. Relaci\u00f3n de DevOps con otros marcos de trabajo: Scrum, Lean, ITIL, ITSM Agile Service Management. Las caracter\u00edsticas de la cultura DevOps. Consideraciones organizativas de DevOps, incluidas las funciones, equipos y estructuras empresariales de DevOps Principales pr\u00e1cticas de DevOps. Pr\u00e1cticas comunes de automatizaci\u00f3n de DevOps y categor\u00edas de herramientas. Desaf\u00edos, riesgos y factores cr\u00edticos de \u00e9xito. Carga horaria: 8 hs. c\u00e1tedra Unidad Tem\u00e1tica 2: Virtualizaci\u00f3n de Plataformas. Operaciones administradas por software. Objetivos espec\u00edficos: Que el alumno comprenda el funcionamiento de las tecnolog\u00edas disponibles para virtualizar plataformas y las diferentes opciones disponibles para el despliegue de aplicaciones empresariales. Que el alumno pueda dise\u00f1ar, poner en marcha, administrar y optimizar soluciones inform\u00e1ticas basadas en virtualizaci\u00f3n y contenedores. Que el alumno reconozca e identifique los diferencias entre las operaciones administradas por software respecto de aquellas gestionadas de la manera tradicional. Contenidos: Virtualizaci\u00f3n de plataformas. Beneficios tecnol\u00f3gicos, econ\u00f3micos y operativos de las infraestructuras din\u00e1micas basadas en virtualizaci\u00f3n. An\u00e1lisis de soluciones para virtualizaci\u00f3n disponibles en el mercado. Escenarios y casos pr\u00e1cticos de implementaci\u00f3n. Virtualizaci\u00f3n de servicios y dispositivos de red. Virtualizaci\u00f3n de almacenamiento. Consolidaci\u00f3n de recursos. Operaciones administradas o definidas por software (SDN, SDS, SDDC). Virtualizaci\u00f3n por contenedores. Orquestaci\u00f3n de contenedores para operaciones de despliegue. Carga horaria: 24 hs. c\u00e1tedra Unidad Tem\u00e1tica 3: Computaci\u00f3n en la nube Objetivos espec\u00edficos: Que el alumno logre comprender los conceptos fundacionales del Cloud Computing para que puedan identificar, administrar y proponer soluciones t\u00e9cnicas que se alberguen en alguna de las plataformas de la nube disponibles. Lograr que el alumno pueda integrar y desplegar aplicaciones en los principales entornos de nube disponibles en el mercado. Contenidos: Cloud Computing. Caracter\u00edsticas. Modelos de despliegue. Modelos o clases de servicio: IaaS, PaaS, SaaS. Casos pr\u00e1cticos. An\u00e1lisis de modelos IaaS: OpenStack, AWS, Azure. Plataformas de desarrollo de aplicaciones en la nube: Amazon Web Services (AWS), Google App Engine (GAE) for Java, Microsoft Azure, IBM Bluemix. Carga horaria: 24 hs. c\u00e1tedra Unidad Tem\u00e1tica 4: Administraci\u00f3n, planificaci\u00f3n y gesti\u00f3n de c\u00f3digo de aplicaciones Objetivos espec\u00edficos: Que el alumno reconozca las principales capacidades requeridas para la administraci\u00f3n, planificaci\u00f3n y gesti\u00f3n del c\u00f3digo de aplicaciones empresariales. Que el alumno pueda poner en marcha diferentes herramientas de gesti\u00f3n y planificaci\u00f3n de proyectos de software, administraci\u00f3n de requerimientos, incidentes y asignaci\u00f3n de trabajo; y repositorios de c\u00f3digo fuente y gesti\u00f3n de versiones. Contenidos: An\u00e1lisis de herramientas de colaboraci\u00f3n y planificaci\u00f3n. Gesti\u00f3n de requerimientos, incidentes y asignaci\u00f3n de trabajo. Casos pr\u00e1cticos. Microsoft Azure DevOps. JIRA. Zendesk. Repositorios de c\u00f3digo. GIT. SVN. Administraci\u00f3n de c\u00f3digo fuente. Gesti\u00f3n de versiones. Paquetes: repositorio de artefactos, distribuci\u00f3n previa a la implementaci\u00f3n de la aplicaci\u00f3n. Configuraci\u00f3n y gesti\u00f3n de la infraestructura, Infraestructura como c\u00f3digo. Revisi\u00f3n de c\u00f3digo fuente, fusi\u00f3n de c\u00f3digo. Carga horaria: 24 hs. c\u00e1tedra Unidad Tem\u00e1tica 5: Aprovisionamiento, despliegue e integraci\u00f3n continua de aplicaciones Objetivos espec\u00edficos: Que el alumno sea capaz de dominar el concepto de integraci\u00f3n y despliegue continuo y sus principales ventajas y desaf\u00edos. Comprender la necesidad del uso de tecnolog\u00edas espec\u00edficas para administraci\u00f3n de tareas de integraci\u00f3n y entrega continua en aplicaciones de diversa escala. Contenidos: Conceptos y herramientas de Integraci\u00f3n, despliegue y entrega continua. Aspectos clave del proceso de desarrollo y entrega. Construcci\u00f3n: herramientas de integraci\u00f3n continua, estado de compilaci\u00f3n. Prueba: herramientas de prueba continuas. Despliegue: gesti\u00f3n de cambios, aprobaciones de versiones, automatizaci\u00f3n de versiones. Despliegue de servicios de datos (SQL, NoSQL). Sincronizaci\u00f3n y mantenimiento de esquemas. Carga horaria: 16 hs. c\u00e1tedra Unidad Tem\u00e1tica 6: Monitoreo y optimizaci\u00f3n de aplicaciones. Objetivos espec\u00edficos: Que el alumno conozca herramientas para telemetr\u00eda, an\u00e1lisis de rendimiento y auditoria de aplicaciones empresariales. Que el alumno pueda identificar elementos, pr\u00e1cticas y tecnolog\u00edas disponibles y necesarias para la protecci\u00f3n, escalamiento y optimizaci\u00f3n de rendimiento de aplicaciones. Contenidos: An\u00e1lisis y monitoreo de m\u00e9tricas de aplicaciones. Registro y captura de errores. Optimizaci\u00f3n de componentes. Herramientas y t\u00e9cnicas de alta disponibilidad y tolerancia a fallos. Escalabilidad de aplicaciones. Copias de seguridad y recuperaci\u00f3n. T\u00e9cnicas avanzadas para la replicaci\u00f3n y sincronizaci\u00f3n de datos. Seguridad para entornos de aplicaciones empresariales. Firewalls. Gesti\u00f3n de entidades. Integraci\u00f3n en entornos h\u00edbridos (nube\u2013en sitio). Pruebas b\u00e1sicas de seguridad. Pruebas de stress. Tecnolog\u00edas para optimizaci\u00f3n de rendimiento y escalamiento de aplicaciones: Cach\u00e9 distribuido, sistemas de colas y mensajer\u00eda, micro servicios, interfaces de programaci\u00f3n de aplicaciones, balanceo de carga, redes de despliegue de contenidos. Carga horaria: 32 hs. c\u00e1tedra","title":"Contenido"},{"location":"contenido/#contenido","text":"","title":"Contenido"},{"location":"contenido/#unidad-tematica-1-introduccion-a-devops","text":"","title":"Unidad Tem\u00e1tica 1: Introducci\u00f3n a DevOps"},{"location":"contenido/#objetivos-especificos","text":"Que el alumno comprenda cu\u00e1les son los desaf\u00edos actuales que enfrenta la gesti\u00f3n completa del ciclo de vida de las aplicaciones, y la relaci\u00f3n de estos con el \u00e1rea de operaciones de TI. Que el alumno conozca cu\u00e1les son las expectativas de las empresas y el mercado del rol de responsable o miembro de un \u00e1rea de DevOps.","title":"Objetivos espec\u00edficos:"},{"location":"contenido/#contenidos","text":"\u00bfQu\u00e9 es DevOps? Antecedentes. Historia. Objetivos. El desarrollo \u00e1gil de software y DEVOPS. Relaci\u00f3n de DevOps con otros marcos de trabajo: Scrum, Lean, ITIL, ITSM Agile Service Management. Las caracter\u00edsticas de la cultura DevOps. Consideraciones organizativas de DevOps, incluidas las funciones, equipos y estructuras empresariales de DevOps Principales pr\u00e1cticas de DevOps. Pr\u00e1cticas comunes de automatizaci\u00f3n de DevOps y categor\u00edas de herramientas. Desaf\u00edos, riesgos y factores cr\u00edticos de \u00e9xito. Carga horaria: 8 hs. c\u00e1tedra","title":"Contenidos:"},{"location":"contenido/#unidad-tematica-2-virtualizacion-de-plataformas-operaciones-administradas-por-software","text":"","title":"Unidad Tem\u00e1tica 2: Virtualizaci\u00f3n de Plataformas. Operaciones administradas por software."},{"location":"contenido/#objetivos-especificos_1","text":"Que el alumno comprenda el funcionamiento de las tecnolog\u00edas disponibles para virtualizar plataformas y las diferentes opciones disponibles para el despliegue de aplicaciones empresariales. Que el alumno pueda dise\u00f1ar, poner en marcha, administrar y optimizar soluciones inform\u00e1ticas basadas en virtualizaci\u00f3n y contenedores. Que el alumno reconozca e identifique los diferencias entre las operaciones administradas por software respecto de aquellas gestionadas de la manera tradicional.","title":"Objetivos espec\u00edficos:"},{"location":"contenido/#contenidos_1","text":"Virtualizaci\u00f3n de plataformas. Beneficios tecnol\u00f3gicos, econ\u00f3micos y operativos de las infraestructuras din\u00e1micas basadas en virtualizaci\u00f3n. An\u00e1lisis de soluciones para virtualizaci\u00f3n disponibles en el mercado. Escenarios y casos pr\u00e1cticos de implementaci\u00f3n. Virtualizaci\u00f3n de servicios y dispositivos de red. Virtualizaci\u00f3n de almacenamiento. Consolidaci\u00f3n de recursos. Operaciones administradas o definidas por software (SDN, SDS, SDDC). Virtualizaci\u00f3n por contenedores. Orquestaci\u00f3n de contenedores para operaciones de despliegue. Carga horaria: 24 hs. c\u00e1tedra","title":"Contenidos:"},{"location":"contenido/#unidad-tematica-3-computacion-en-la-nube","text":"","title":"Unidad Tem\u00e1tica 3: Computaci\u00f3n en la nube"},{"location":"contenido/#objetivos-especificos_2","text":"Que el alumno logre comprender los conceptos fundacionales del Cloud Computing para que puedan identificar, administrar y proponer soluciones t\u00e9cnicas que se alberguen en alguna de las plataformas de la nube disponibles. Lograr que el alumno pueda integrar y desplegar aplicaciones en los principales entornos de nube disponibles en el mercado.","title":"Objetivos espec\u00edficos:"},{"location":"contenido/#contenidos_2","text":"Cloud Computing. Caracter\u00edsticas. Modelos de despliegue. Modelos o clases de servicio: IaaS, PaaS, SaaS. Casos pr\u00e1cticos. An\u00e1lisis de modelos IaaS: OpenStack, AWS, Azure. Plataformas de desarrollo de aplicaciones en la nube: Amazon Web Services (AWS), Google App Engine (GAE) for Java, Microsoft Azure, IBM Bluemix. Carga horaria: 24 hs. c\u00e1tedra","title":"Contenidos:"},{"location":"contenido/#unidad-tematica-4-administracion-planificacion-y-gestion-de-codigo-de-aplicaciones","text":"","title":"Unidad Tem\u00e1tica 4: Administraci\u00f3n, planificaci\u00f3n y gesti\u00f3n de c\u00f3digo de aplicaciones"},{"location":"contenido/#objetivos-especificos_3","text":"Que el alumno reconozca las principales capacidades requeridas para la administraci\u00f3n, planificaci\u00f3n y gesti\u00f3n del c\u00f3digo de aplicaciones empresariales. Que el alumno pueda poner en marcha diferentes herramientas de gesti\u00f3n y planificaci\u00f3n de proyectos de software, administraci\u00f3n de requerimientos, incidentes y asignaci\u00f3n de trabajo; y repositorios de c\u00f3digo fuente y gesti\u00f3n de versiones.","title":"Objetivos espec\u00edficos:"},{"location":"contenido/#contenidos_3","text":"An\u00e1lisis de herramientas de colaboraci\u00f3n y planificaci\u00f3n. Gesti\u00f3n de requerimientos, incidentes y asignaci\u00f3n de trabajo. Casos pr\u00e1cticos. Microsoft Azure DevOps. JIRA. Zendesk. Repositorios de c\u00f3digo. GIT. SVN. Administraci\u00f3n de c\u00f3digo fuente. Gesti\u00f3n de versiones. Paquetes: repositorio de artefactos, distribuci\u00f3n previa a la implementaci\u00f3n de la aplicaci\u00f3n. Configuraci\u00f3n y gesti\u00f3n de la infraestructura, Infraestructura como c\u00f3digo. Revisi\u00f3n de c\u00f3digo fuente, fusi\u00f3n de c\u00f3digo. Carga horaria: 24 hs. c\u00e1tedra","title":"Contenidos:"},{"location":"contenido/#unidad-tematica-5-aprovisionamiento-despliegue-e-integracion-continua-de-aplicaciones","text":"","title":"Unidad Tem\u00e1tica 5: Aprovisionamiento, despliegue e integraci\u00f3n continua de aplicaciones"},{"location":"contenido/#objetivos-especificos_4","text":"Que el alumno sea capaz de dominar el concepto de integraci\u00f3n y despliegue continuo y sus principales ventajas y desaf\u00edos. Comprender la necesidad del uso de tecnolog\u00edas espec\u00edficas para administraci\u00f3n de tareas de integraci\u00f3n y entrega continua en aplicaciones de diversa escala.","title":"Objetivos espec\u00edficos:"},{"location":"contenido/#contenidos_4","text":"Conceptos y herramientas de Integraci\u00f3n, despliegue y entrega continua. Aspectos clave del proceso de desarrollo y entrega. Construcci\u00f3n: herramientas de integraci\u00f3n continua, estado de compilaci\u00f3n. Prueba: herramientas de prueba continuas. Despliegue: gesti\u00f3n de cambios, aprobaciones de versiones, automatizaci\u00f3n de versiones. Despliegue de servicios de datos (SQL, NoSQL). Sincronizaci\u00f3n y mantenimiento de esquemas. Carga horaria: 16 hs. c\u00e1tedra","title":"Contenidos:"},{"location":"contenido/#unidad-tematica-6-monitoreo-y-optimizacion-de-aplicaciones","text":"","title":"Unidad Tem\u00e1tica 6: Monitoreo y optimizaci\u00f3n de aplicaciones."},{"location":"contenido/#objetivos-especificos_5","text":"Que el alumno conozca herramientas para telemetr\u00eda, an\u00e1lisis de rendimiento y auditoria de aplicaciones empresariales. Que el alumno pueda identificar elementos, pr\u00e1cticas y tecnolog\u00edas disponibles y necesarias para la protecci\u00f3n, escalamiento y optimizaci\u00f3n de rendimiento de aplicaciones.","title":"Objetivos espec\u00edficos:"},{"location":"contenido/#contenidos_5","text":"An\u00e1lisis y monitoreo de m\u00e9tricas de aplicaciones. Registro y captura de errores. Optimizaci\u00f3n de componentes. Herramientas y t\u00e9cnicas de alta disponibilidad y tolerancia a fallos. Escalabilidad de aplicaciones. Copias de seguridad y recuperaci\u00f3n. T\u00e9cnicas avanzadas para la replicaci\u00f3n y sincronizaci\u00f3n de datos. Seguridad para entornos de aplicaciones empresariales. Firewalls. Gesti\u00f3n de entidades. Integraci\u00f3n en entornos h\u00edbridos (nube\u2013en sitio). Pruebas b\u00e1sicas de seguridad. Pruebas de stress. Tecnolog\u00edas para optimizaci\u00f3n de rendimiento y escalamiento de aplicaciones: Cach\u00e9 distribuido, sistemas de colas y mensajer\u00eda, micro servicios, interfaces de programaci\u00f3n de aplicaciones, balanceo de carga, redes de despliegue de contenidos. Carga horaria: 32 hs. c\u00e1tedra","title":"Contenidos:"},{"location":"otros/kubernetes-containerd/","text":"Kubernetes installation with containerd A continuaci\u00f3n se lista la instrucciones para instalar todos los componentes necesarios para instalar Kubernetes con ContainerD como runtime. Partiendo de una sistema operativo Ubuntu 22.04 fresco. Upgrade del Sistema sudo sed -i 's/#$nrconf{restart} = ' \"'\" 'i' \"'\" ';/$nrconf{restart} = ' \"'\" 'a' \"'\" ';/g' /etc/needrestart/needrestart.conf sudo apt-get update sudo apt-get upgrade -y Instalaci\u00f3n containerd wget https://github.com/containerd/containerd/releases/download/v1.6.8/containerd-1.6.8-linux-amd64.tar.gz sudo tar Cxzvf /usr/local containerd-1.6.8-linux-amd64.tar.gz rm containerd-1.6.8-linux-amd64.tar.gz wget https://raw.githubusercontent.com/containerd/containerd/main/containerd.service sudo mv containerd.service /etc/systemd/system/ sudo systemctl daemon-reload sudo systemctl enable containerd sudo systemctl start containerd Instalaci\u00f3n runc wget https://github.com/opencontainers/runc/releases/download/v1.1.4/runc.amd64 sudo install -m 755 runc.amd64 /usr/local/sbin/runc rm runc.amd64 Instalaci\u00f3n CNI Plugins sudo mkdir -p /opt/cni/bin wget https://github.com/containernetworking/plugins/releases/download/v1.1.1/cni-plugins-linux-amd64-v1.1.1.tgz sudo tar Cxzvf /opt/cni/bin cni-plugins-linux-amd64-v1.1.1.tgz rm cni-plugins-linux-amd64-v1.1.1.tgz Instalaci\u00f3n nerdctl wget https://github.com/containerd/nerdctl/releases/download/v0.23.0/nerdctl-0.23.0-linux-amd64.tar.gz sudo tar Cxzvvf /usr/local/bin nerdctl-0.23.0-linux-amd64.tar.gz rm nerdctl-0.23.0-linux-amd64.tar.gz Configuraci\u00f3n Sistema Operativo cat <<EOF | sudo tee /etc/modules-load.d/k8s.conf overlay br_netfilter EOF sudo modprobe overlay sudo modprobe br_netfilter cat <<EOF | sudo tee /etc/sysctl.d/k8s.conf net.bridge.bridge-nf-call-iptables = 1 net.bridge.bridge-nf-call-ip6tables = 1 net.ipv4.ip_forward = 1 EOF sudo sysctl --system Configuraci\u00f3n containerd sudo mkdir -p /etc/containerd containerd config default | sudo tee /etc/containerd/config.toml sudo sed -i 's/SystemdCgroup = false/SystemdCgroup = true/g' /etc/containerd/config.toml sudo systemctl restart containerd Instalaci\u00f3n paquetes necesarios sudo apt-get update sudo apt-get install -y apt-transport-https ca-certificates curl Instalaci\u00f3n repositorios Kubernetes sudo curl -fsSLo /usr/share/keyrings/kubernetes-archive-keyring.gpg https://packages.cloud.google.com/apt/doc/apt-key.gpg echo \"deb [signed-by=/usr/share/keyrings/kubernetes-archive-keyring.gpg] https://apt.kubernetes.io/ kubernetes-xenial main\" | sudo tee /etc/apt/sources.list.d/kubernetes.list sudo apt-get update Instalaci\u00f3n Kubernetes sudo apt-get install -y kubelet = 1 .25.0-00 kubeadm = 1 .25.0-00 kubectl = 1 .25.0-00 sudo apt-mark hold kubelet kubeadm kubectl Inicializacion Cluster sudo kubeadm init --kubernetes-version 1 .25.0 Configuracion Cluster mkdir -p $HOME /.kube sudo cp -i /etc/kubernetes/admin.conf $HOME /.kube/config sudo chown $( id -u ) : $( id -g ) $HOME /.kube/config kubectl apply -f \"https://cloud.weave.works/k8s/net?k8s-version= $( kubectl version | base64 | tr -d '\\n' ) \"","title":"K8s - containerd"},{"location":"otros/kubernetes-containerd/#kubernetes-installation-with-containerd","text":"A continuaci\u00f3n se lista la instrucciones para instalar todos los componentes necesarios para instalar Kubernetes con ContainerD como runtime. Partiendo de una sistema operativo Ubuntu 22.04 fresco. Upgrade del Sistema sudo sed -i 's/#$nrconf{restart} = ' \"'\" 'i' \"'\" ';/$nrconf{restart} = ' \"'\" 'a' \"'\" ';/g' /etc/needrestart/needrestart.conf sudo apt-get update sudo apt-get upgrade -y Instalaci\u00f3n containerd wget https://github.com/containerd/containerd/releases/download/v1.6.8/containerd-1.6.8-linux-amd64.tar.gz sudo tar Cxzvf /usr/local containerd-1.6.8-linux-amd64.tar.gz rm containerd-1.6.8-linux-amd64.tar.gz wget https://raw.githubusercontent.com/containerd/containerd/main/containerd.service sudo mv containerd.service /etc/systemd/system/ sudo systemctl daemon-reload sudo systemctl enable containerd sudo systemctl start containerd Instalaci\u00f3n runc wget https://github.com/opencontainers/runc/releases/download/v1.1.4/runc.amd64 sudo install -m 755 runc.amd64 /usr/local/sbin/runc rm runc.amd64 Instalaci\u00f3n CNI Plugins sudo mkdir -p /opt/cni/bin wget https://github.com/containernetworking/plugins/releases/download/v1.1.1/cni-plugins-linux-amd64-v1.1.1.tgz sudo tar Cxzvf /opt/cni/bin cni-plugins-linux-amd64-v1.1.1.tgz rm cni-plugins-linux-amd64-v1.1.1.tgz Instalaci\u00f3n nerdctl wget https://github.com/containerd/nerdctl/releases/download/v0.23.0/nerdctl-0.23.0-linux-amd64.tar.gz sudo tar Cxzvvf /usr/local/bin nerdctl-0.23.0-linux-amd64.tar.gz rm nerdctl-0.23.0-linux-amd64.tar.gz Configuraci\u00f3n Sistema Operativo cat <<EOF | sudo tee /etc/modules-load.d/k8s.conf overlay br_netfilter EOF sudo modprobe overlay sudo modprobe br_netfilter cat <<EOF | sudo tee /etc/sysctl.d/k8s.conf net.bridge.bridge-nf-call-iptables = 1 net.bridge.bridge-nf-call-ip6tables = 1 net.ipv4.ip_forward = 1 EOF sudo sysctl --system Configuraci\u00f3n containerd sudo mkdir -p /etc/containerd containerd config default | sudo tee /etc/containerd/config.toml sudo sed -i 's/SystemdCgroup = false/SystemdCgroup = true/g' /etc/containerd/config.toml sudo systemctl restart containerd Instalaci\u00f3n paquetes necesarios sudo apt-get update sudo apt-get install -y apt-transport-https ca-certificates curl Instalaci\u00f3n repositorios Kubernetes sudo curl -fsSLo /usr/share/keyrings/kubernetes-archive-keyring.gpg https://packages.cloud.google.com/apt/doc/apt-key.gpg echo \"deb [signed-by=/usr/share/keyrings/kubernetes-archive-keyring.gpg] https://apt.kubernetes.io/ kubernetes-xenial main\" | sudo tee /etc/apt/sources.list.d/kubernetes.list sudo apt-get update Instalaci\u00f3n Kubernetes sudo apt-get install -y kubelet = 1 .25.0-00 kubeadm = 1 .25.0-00 kubectl = 1 .25.0-00 sudo apt-mark hold kubelet kubeadm kubectl Inicializacion Cluster sudo kubeadm init --kubernetes-version 1 .25.0 Configuracion Cluster mkdir -p $HOME /.kube sudo cp -i /etc/kubernetes/admin.conf $HOME /.kube/config sudo chown $( id -u ) : $( id -g ) $HOME /.kube/config kubectl apply -f \"https://cloud.weave.works/k8s/net?k8s-version= $( kubectl version | base64 | tr -d '\\n' ) \"","title":"Kubernetes installation with containerd"},{"location":"otros/kubernetes-crio/","text":"Kubernetes installation with CRI-O A continuaci\u00f3n se lista la instrucciones para instalar todos los componentes necesarios para instalar Kubernetes con CRI-O como runtime. Partiendo de una sistema operativo Ubuntu 22.04 fresco. Upgrade del Sistema sudo sed -i 's/#$nrconf{restart} = ' \"'\" 'i' \"'\" ';/$nrconf{restart} = ' \"'\" 'a' \"'\" ';/g' /etc/needrestart/needrestart.conf sudo apt-get update sudo apt-get upgrade -y Instalaci\u00f3n CRI-O export OS = xUbuntu_22.04 export VERSION = 1 .25 echo \"deb [signed-by=/usr/share/keyrings/libcontainers-archive-keyring.gpg] https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/ $OS / /\" | sudo tee /etc/apt/sources.list.d/devel:kubic:libcontainers:stable.list echo \"deb [signed-by=/usr/share/keyrings/libcontainers-crio-archive-keyring.gpg] https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable:/cri-o:/ $VERSION / $OS / /\" | sudo tee /etc/apt/sources.list.d/devel:kubic:libcontainers:stable:cri-o: $VERSION .list sudo mkdir -p /usr/share/keyrings curl -L https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/ $OS /Release.key | sudo gpg --dearmor -o /usr/share/keyrings/libcontainers-archive-keyring.gpg curl -L https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable:/cri-o:/ $VERSION / $OS /Release.key | sudo gpg --dearmor -o /usr/share/keyrings/libcontainers-crio-archive-keyring.gpg sudo apt-get update sudo apt-get install cri-o cri-o-runc -y Configuraci\u00f3n Sistema Operativo cat <<EOF | sudo tee /etc/modules-load.d/k8s.conf overlay br_netfilter EOF sudo modprobe overlay sudo modprobe br_netfilter cat <<EOF | sudo tee /etc/sysctl.d/k8s.conf net.bridge.bridge-nf-call-iptables = 1 net.bridge.bridge-nf-call-ip6tables = 1 net.ipv4.ip_forward = 1 EOF sudo sysctl --system Instalaci\u00f3n paquetes necesarios sudo apt-get update sudo apt-get install -y apt-transport-https ca-certificates curl Instalaci\u00f3n repositorios Kubernetes sudo curl -fsSLo /usr/share/keyrings/kubernetes-archive-keyring.gpg https://packages.cloud.google.com/apt/doc/apt-key.gpg echo \"deb [signed-by=/usr/share/keyrings/kubernetes-archive-keyring.gpg] https://apt.kubernetes.io/ kubernetes-xenial main\" | sudo tee /etc/apt/sources.list.d/kubernetes.list sudo apt-get update Instalaci\u00f3n Kubernetes sudo apt-get install -y kubelet = 1 .25.0-00 kubeadm = 1 .25.0-00 kubectl = 1 .25.0-00 sudo apt-mark hold kubelet kubeadm kubectl Inicializacion Cluster sudo kubeadm init --kubernetes-version 1 .25.0 Configuracion Cluster mkdir -p $HOME /.kube sudo cp -i /etc/kubernetes/admin.conf $HOME /.kube/config sudo chown $( id -u ) : $( id -g ) $HOME /.kube/config kubectl apply -f \"https://cloud.weave.works/k8s/net?k8s-version= $( kubectl version | base64 | tr -d '\\n' ) \"","title":"K8s - CRI-O"},{"location":"otros/kubernetes-crio/#kubernetes-installation-with-cri-o","text":"A continuaci\u00f3n se lista la instrucciones para instalar todos los componentes necesarios para instalar Kubernetes con CRI-O como runtime. Partiendo de una sistema operativo Ubuntu 22.04 fresco. Upgrade del Sistema sudo sed -i 's/#$nrconf{restart} = ' \"'\" 'i' \"'\" ';/$nrconf{restart} = ' \"'\" 'a' \"'\" ';/g' /etc/needrestart/needrestart.conf sudo apt-get update sudo apt-get upgrade -y Instalaci\u00f3n CRI-O export OS = xUbuntu_22.04 export VERSION = 1 .25 echo \"deb [signed-by=/usr/share/keyrings/libcontainers-archive-keyring.gpg] https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/ $OS / /\" | sudo tee /etc/apt/sources.list.d/devel:kubic:libcontainers:stable.list echo \"deb [signed-by=/usr/share/keyrings/libcontainers-crio-archive-keyring.gpg] https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable:/cri-o:/ $VERSION / $OS / /\" | sudo tee /etc/apt/sources.list.d/devel:kubic:libcontainers:stable:cri-o: $VERSION .list sudo mkdir -p /usr/share/keyrings curl -L https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/ $OS /Release.key | sudo gpg --dearmor -o /usr/share/keyrings/libcontainers-archive-keyring.gpg curl -L https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable:/cri-o:/ $VERSION / $OS /Release.key | sudo gpg --dearmor -o /usr/share/keyrings/libcontainers-crio-archive-keyring.gpg sudo apt-get update sudo apt-get install cri-o cri-o-runc -y Configuraci\u00f3n Sistema Operativo cat <<EOF | sudo tee /etc/modules-load.d/k8s.conf overlay br_netfilter EOF sudo modprobe overlay sudo modprobe br_netfilter cat <<EOF | sudo tee /etc/sysctl.d/k8s.conf net.bridge.bridge-nf-call-iptables = 1 net.bridge.bridge-nf-call-ip6tables = 1 net.ipv4.ip_forward = 1 EOF sudo sysctl --system Instalaci\u00f3n paquetes necesarios sudo apt-get update sudo apt-get install -y apt-transport-https ca-certificates curl Instalaci\u00f3n repositorios Kubernetes sudo curl -fsSLo /usr/share/keyrings/kubernetes-archive-keyring.gpg https://packages.cloud.google.com/apt/doc/apt-key.gpg echo \"deb [signed-by=/usr/share/keyrings/kubernetes-archive-keyring.gpg] https://apt.kubernetes.io/ kubernetes-xenial main\" | sudo tee /etc/apt/sources.list.d/kubernetes.list sudo apt-get update Instalaci\u00f3n Kubernetes sudo apt-get install -y kubelet = 1 .25.0-00 kubeadm = 1 .25.0-00 kubectl = 1 .25.0-00 sudo apt-mark hold kubelet kubeadm kubectl Inicializacion Cluster sudo kubeadm init --kubernetes-version 1 .25.0 Configuracion Cluster mkdir -p $HOME /.kube sudo cp -i /etc/kubernetes/admin.conf $HOME /.kube/config sudo chown $( id -u ) : $( id -g ) $HOME /.kube/config kubectl apply -f \"https://cloud.weave.works/k8s/net?k8s-version= $( kubectl version | base64 | tr -d '\\n' ) \"","title":"Kubernetes installation with CRI-O"},{"location":"practica/ci-cd/","text":"CI-CD Ejercicio 1 Descargar la siguiente maquina virtual Desplegar la maquina virtual en virtualbox Validar la instalaci\u00f3n y el repo tuto creado Intentar realizar un nuevo despliegue Forquear el repo y crear un nuevo pipeline a partir del mismo. Validarlo. Modificar el pipeline para que podman ejecute la imagen hello world Modificar el pipeline para que kubectl pueda consultar el estado del cluster K8s. Crear una imagen con el paquete fortune adentro, configurar el pod template con el nuevo container y luego agregarlo al pipeline para que se ejecute Ejercicio 2 Crear un pipeline (a partir de un Jenkinsfile) que compile el dockerfile del siguiente proyecto Modificar el pipeline para que cuando se ejecute en la rama develop haga el build de una imagen anterior, y cuando este en la rama master haga un kubectl get pod del cluster Modificar el pipeline para que cuando se ejecute en la rama develop haga el build de la imagen y lo pushee a dockerhub Modificar el pipeline para que aplique los manifiestos (con kubectl ) creados para la aplicacion web-go vista anteriormente Modificar el pipeline para que en la rama develop construya la imagen y la publique y que en la rama master aplique el manifiesto Modificar el pipeline para que actualice la imagen del deployment con la nueva imagen construida (esto se logra utilizando el BUILD_NUMBER del job de jenkins). Modificar el pipeline para que en la rama develop contruya la imagen, la publique y luega tambien que despliegue el manifiesto en una namespace de desarrollo, y que en la rama master solo despliegue el manifiesto en el namespace de produccion (es posible que se necesite dos manifiestos) Recursos Usar un Jenkinsfile Sintaxis Docker Pipeline plugin K8s Plugin Variables de ambiente ${YOUR_JENKINS_HOST}/env-vars.html","title":"CI/CD"},{"location":"practica/ci-cd/#ci-cd","text":"","title":"CI-CD"},{"location":"practica/ci-cd/#ejercicio-1","text":"Descargar la siguiente maquina virtual Desplegar la maquina virtual en virtualbox Validar la instalaci\u00f3n y el repo tuto creado Intentar realizar un nuevo despliegue Forquear el repo y crear un nuevo pipeline a partir del mismo. Validarlo. Modificar el pipeline para que podman ejecute la imagen hello world Modificar el pipeline para que kubectl pueda consultar el estado del cluster K8s. Crear una imagen con el paquete fortune adentro, configurar el pod template con el nuevo container y luego agregarlo al pipeline para que se ejecute","title":"Ejercicio 1"},{"location":"practica/ci-cd/#ejercicio-2","text":"Crear un pipeline (a partir de un Jenkinsfile) que compile el dockerfile del siguiente proyecto Modificar el pipeline para que cuando se ejecute en la rama develop haga el build de una imagen anterior, y cuando este en la rama master haga un kubectl get pod del cluster Modificar el pipeline para que cuando se ejecute en la rama develop haga el build de la imagen y lo pushee a dockerhub Modificar el pipeline para que aplique los manifiestos (con kubectl ) creados para la aplicacion web-go vista anteriormente Modificar el pipeline para que en la rama develop construya la imagen y la publique y que en la rama master aplique el manifiesto Modificar el pipeline para que actualice la imagen del deployment con la nueva imagen construida (esto se logra utilizando el BUILD_NUMBER del job de jenkins). Modificar el pipeline para que en la rama develop contruya la imagen, la publique y luega tambien que despliegue el manifiesto en una namespace de desarrollo, y que en la rama master solo despliegue el manifiesto en el namespace de produccion (es posible que se necesite dos manifiestos)","title":"Ejercicio 2"},{"location":"practica/ci-cd/#recursos","text":"Usar un Jenkinsfile Sintaxis Docker Pipeline plugin K8s Plugin Variables de ambiente ${YOUR_JENKINS_HOST}/env-vars.html","title":"Recursos"},{"location":"practica/containers/","text":"Containers Ejercicio 1 Restaurar la instant\u00e1nea docker en la maquina virtual sin resguardar ningun cambio e iniciar la VM Crear una imagen basada en Ubuntu e instalar nginx desde repositorio oficial del producto Correr la imagen exponiendo el puerto correspondiente y verificar su funcionamiento desde el host Realizar las configuraciones necesarias a la VM para que el servicio pueda ser accedido desde la red del aula. Verificar con algun compa\u00f1ero que el servicio de nginx puede ser accedido a traves de la red. Apagar la maquina virtual y realizar una instantanea de nombre nginx Ejercicio 2 Restaurar la instant\u00e1nea podman en la VM Crear una imagen basada en CentOS 7 e instalar httpd del repositorio del sistema operativo Correr la imagen exponiendo el puerto correspondiente y verificar su funcionamiento desde el host Realizar las configuraciones necesarias a la VM para que el servicio pueda ser accedido desde la red del aula. Verificar con algun compa\u00f1ero que el servicio de httpd puede ser accedido a traves de la red. Apagar la maquina virtual y realizar una instantanea de nombre httpd Ejercicio 3 Restaurar la instant\u00e1nea containerd en la maquina virtual Crear una imagen basada en alpine e instalar en el mismo minio Correr la imagen en el puerto por defecto de aplicacion y verificar su funcionamiento desde el host Cambiar las propiedades de red de la maquina virtual para la misma poseea una direcci\u00f3n IP del segmento de red del aula. Verificar con algun compa\u00f1ero que el servicio de minio puede ser accedido a traves de la red. Apagar la maquina virtual y realizar una instantanea de nombre minio Ejercicio 4 Restaurar la instant\u00e1nea nginx creada anteriormente Crear un archivo html en el host que diga 'DevOps 2022' y montarlo en el container para que sea servido por el servidor web Acceder nuevamente desde algun otra pc dentro de la red del aula Ejercicio 5 Restaurar la instant\u00e1nea httpd creada anteriormente descartando cualquier cambio anterior Crear un archivo html en el host que diga 'DevOps 2022' y montarlo en el container para que sea servido por el servidor web Acceder nuevamente desde algun otra pc dentro de la red del aula Ejercicio 6 Restaurar la instant\u00e1nea minio creada anteriormente descartando cualquier cambio anterior Montar una carpeta del hots para que los datos se guarden en el host. Acceder nuevamente desde algun otra pc dentro de la red del aula Ejercicio 7 Crease una cuenta en DockerHub Pushear las imagenes creadas anteriormente. Probarlas desde otro computador del aula Ejercicio 8 Realizar grupos de 2 personas El primer integrante restaura en su PC la instant\u00e1nea docker El segundo integrante restaura en su PC la instant\u00e1nea podman El primer integrante tiene que crear una imagen basada en Ubuntu con OpenSSH Server instalado El segundo integrante tiene que crear una imagen basada en CentOS 7 con OpenSSH Server instalado Ambos deben ejecutar la imagen exponiendo el servidor SSH en algun puerto de su elecci\u00f3n Ingresar cada uno por ssh desde el host al container del otro","title":"Contenedores"},{"location":"practica/containers/#containers","text":"","title":"Containers"},{"location":"practica/containers/#ejercicio-1","text":"Restaurar la instant\u00e1nea docker en la maquina virtual sin resguardar ningun cambio e iniciar la VM Crear una imagen basada en Ubuntu e instalar nginx desde repositorio oficial del producto Correr la imagen exponiendo el puerto correspondiente y verificar su funcionamiento desde el host Realizar las configuraciones necesarias a la VM para que el servicio pueda ser accedido desde la red del aula. Verificar con algun compa\u00f1ero que el servicio de nginx puede ser accedido a traves de la red. Apagar la maquina virtual y realizar una instantanea de nombre nginx","title":"Ejercicio 1"},{"location":"practica/containers/#ejercicio-2","text":"Restaurar la instant\u00e1nea podman en la VM Crear una imagen basada en CentOS 7 e instalar httpd del repositorio del sistema operativo Correr la imagen exponiendo el puerto correspondiente y verificar su funcionamiento desde el host Realizar las configuraciones necesarias a la VM para que el servicio pueda ser accedido desde la red del aula. Verificar con algun compa\u00f1ero que el servicio de httpd puede ser accedido a traves de la red. Apagar la maquina virtual y realizar una instantanea de nombre httpd","title":"Ejercicio 2"},{"location":"practica/containers/#ejercicio-3","text":"Restaurar la instant\u00e1nea containerd en la maquina virtual Crear una imagen basada en alpine e instalar en el mismo minio Correr la imagen en el puerto por defecto de aplicacion y verificar su funcionamiento desde el host Cambiar las propiedades de red de la maquina virtual para la misma poseea una direcci\u00f3n IP del segmento de red del aula. Verificar con algun compa\u00f1ero que el servicio de minio puede ser accedido a traves de la red. Apagar la maquina virtual y realizar una instantanea de nombre minio","title":"Ejercicio 3"},{"location":"practica/containers/#ejercicio-4","text":"Restaurar la instant\u00e1nea nginx creada anteriormente Crear un archivo html en el host que diga 'DevOps 2022' y montarlo en el container para que sea servido por el servidor web Acceder nuevamente desde algun otra pc dentro de la red del aula","title":"Ejercicio 4"},{"location":"practica/containers/#ejercicio-5","text":"Restaurar la instant\u00e1nea httpd creada anteriormente descartando cualquier cambio anterior Crear un archivo html en el host que diga 'DevOps 2022' y montarlo en el container para que sea servido por el servidor web Acceder nuevamente desde algun otra pc dentro de la red del aula","title":"Ejercicio 5"},{"location":"practica/containers/#ejercicio-6","text":"Restaurar la instant\u00e1nea minio creada anteriormente descartando cualquier cambio anterior Montar una carpeta del hots para que los datos se guarden en el host. Acceder nuevamente desde algun otra pc dentro de la red del aula","title":"Ejercicio 6"},{"location":"practica/containers/#ejercicio-7","text":"Crease una cuenta en DockerHub Pushear las imagenes creadas anteriormente. Probarlas desde otro computador del aula","title":"Ejercicio 7"},{"location":"practica/containers/#ejercicio-8","text":"Realizar grupos de 2 personas El primer integrante restaura en su PC la instant\u00e1nea docker El segundo integrante restaura en su PC la instant\u00e1nea podman El primer integrante tiene que crear una imagen basada en Ubuntu con OpenSSH Server instalado El segundo integrante tiene que crear una imagen basada en CentOS 7 con OpenSSH Server instalado Ambos deben ejecutar la imagen exponiendo el servidor SSH en algun puerto de su elecci\u00f3n Ingresar cada uno por ssh desde el host al container del otro","title":"Ejercicio 8"},{"location":"practica/dbs/","text":"Base de Datos en CI-CD Ejercicio 1 Realizar las siguientes actividades Crear un container con una base de Datos MySQL Crear un conjunto de scripts que realicen los siguiente (uno por archivo) Crear tablas Agregar columnas Eliminar columnas Borrar datos en una tabla Validar que los scripts funcionen Versionar los scripts para que puedan ser interpretados por flyway Todas tienen que ser migraciones menos el script que borra datos, el cual tiene que ser repetible Usar la imagen de flyway y aplicar los scripts en la base de datos. Volver a ejecutar el mismo conjunto de scripts y validar los resultados. Crear un nuevo script con numero de version anterior a los aplicados y validar su aplicacion. Ejercicio 2 En el entorno de Jenkins creado en Kubernetes Crear un pod template que contenga el container de flyway Crear un repositorio que contenga el siguiente manifiesto para desplegar una base de datos MySQL Agregar los scripts del ejercicio anterior al repositorio Crear un pipeline que despliega la base de datos y ademas aplica con el container de flyway los scripts anteriores Agregar un nuevo scripts en el repositorio y validar su aplicacion por el pipeline.","title":"Bases de Datos"},{"location":"practica/dbs/#base-de-datos-en-ci-cd","text":"","title":"Base de Datos en CI-CD"},{"location":"practica/dbs/#ejercicio-1","text":"Realizar las siguientes actividades Crear un container con una base de Datos MySQL Crear un conjunto de scripts que realicen los siguiente (uno por archivo) Crear tablas Agregar columnas Eliminar columnas Borrar datos en una tabla Validar que los scripts funcionen Versionar los scripts para que puedan ser interpretados por flyway Todas tienen que ser migraciones menos el script que borra datos, el cual tiene que ser repetible Usar la imagen de flyway y aplicar los scripts en la base de datos. Volver a ejecutar el mismo conjunto de scripts y validar los resultados. Crear un nuevo script con numero de version anterior a los aplicados y validar su aplicacion.","title":"Ejercicio 1"},{"location":"practica/dbs/#ejercicio-2","text":"En el entorno de Jenkins creado en Kubernetes Crear un pod template que contenga el container de flyway Crear un repositorio que contenga el siguiente manifiesto para desplegar una base de datos MySQL Agregar los scripts del ejercicio anterior al repositorio Crear un pipeline que despliega la base de datos y ademas aplica con el container de flyway los scripts anteriores Agregar un nuevo scripts en el repositorio y validar su aplicacion por el pipeline.","title":"Ejercicio 2"},{"location":"practica/orquestation/","text":"Orquestaci\u00f3n de Containers Ejercicio 1 - Crear Cluster Kubernetes Configurar Red Crear una red NAT en el segmento 10.0.2.0/24 Compartir la conexion de internet con el adaptador asociado Partir de las vms Ubuntu y CentOS creadas en los TPs anteriores Configurar Master Elegir entra la vm ubuntu y centos para el master Clonar la VM elegida como master Configurarle 2 CPUs Actualizar Sistema Operativo Configurar iptables Configurar el Container Runtime Instalar Kubeadm Configurar el cgroup driver para usar systemd Disable Swap Configurar red y configurar el adaptador de red para que sea NAT Network con la red creada anteriormente Direccion IP: 10.0.2.10 Hostname: master Ejecutar kubeadm config images pull Ejectuar kubeadm init phase preflight para validar la instalaci\u00f3n Apagar la VM Crear un Snapshot de la vm llamada kube Configurar Worker Clonar la vm restante como worker Configurarle 2 CPUs Configurar iptables Configurar el Container Runtime Instalar Kubeadm Configurar el cgroup driver para usar systemd Disable Swap Configurar red y configurar el adaptador de red para que sea NAT Network con la red creada anteriormente Direccion IP: 10.0.2.11 Hostname: worker Ejecutar kubeadm config images pull Ejectuar kubeadm init phase preflight para validar la instalaci\u00f3n Apagar la VM Crear un Snapshot de la vm llamada kube Crear Cluster Prender las vms Verificar conexion de red entre el host y las vms Verificar conexion de red entre las vms Configurar el archivo host en las vms como en tu pc con el nombre k8s a la ip 10.0.2.10 En la vm master ejecutar kubeadm init con los parametros necesarios para llegar por el nombre k8s En la vm worker ejecutar kubeadm join con los parametros necesarios para llegar por el nombre k8s Verificaci\u00f3n Copiar el kubeconfig a la pc e intentar hacer consultas con kubectl Realizar consultas a la API directamente con curl, usando tokens y certificados Ejercicio 2 Clonarse el siguiente repositorio: web-go Analizar el codigo y el Dockerfile Construir la imagen y pushearla a un repo propio en dockerhub Testear la imagen localmente con docker Generar los siguientes recursos necesarios para ejecutar esta servidor web en Kubernetes teniendo en cuenta lo siguiente: Los recursos tienen que estar en un namespace independiente Las variables de ambiente FOO y BAR deben ser montadas mediante ConfigMaps en el despliegue Las variables de ambiente SUPERSECRETUSER y SUPERSECRETPASS deben ser montadas mediante Secrets en el despliegue Deben haber al menos dos pods corriendo Se debe poder acceder a estos recursos por Ingress Teniendo en cuenta lo armado, duplicar los recursos teniendo en cuenta lo siguiente Los recursos tienen que estar en un namespace distinto al anterior Se debe poder acceder a los servicios de este namespace por un path distinto al anterior Modificar el archivo web.go agregando un nueva impresion por pantalla Construir la imagen y pushearla con un tag nuevo (ej. v2 ) Modificar los recursos necesarios para que kubernetes despliegue la nueva version.","title":"Orquestaci\u00f3n"},{"location":"practica/orquestation/#orquestacion-de-containers","text":"","title":"Orquestaci\u00f3n de Containers"},{"location":"practica/orquestation/#ejercicio-1-crear-cluster-kubernetes","text":"","title":"Ejercicio 1 - Crear Cluster Kubernetes"},{"location":"practica/orquestation/#configurar-red","text":"Crear una red NAT en el segmento 10.0.2.0/24 Compartir la conexion de internet con el adaptador asociado Partir de las vms Ubuntu y CentOS creadas en los TPs anteriores","title":"Configurar Red"},{"location":"practica/orquestation/#configurar-master","text":"Elegir entra la vm ubuntu y centos para el master Clonar la VM elegida como master Configurarle 2 CPUs Actualizar Sistema Operativo Configurar iptables Configurar el Container Runtime Instalar Kubeadm Configurar el cgroup driver para usar systemd Disable Swap Configurar red y configurar el adaptador de red para que sea NAT Network con la red creada anteriormente Direccion IP: 10.0.2.10 Hostname: master Ejecutar kubeadm config images pull Ejectuar kubeadm init phase preflight para validar la instalaci\u00f3n Apagar la VM Crear un Snapshot de la vm llamada kube","title":"Configurar Master"},{"location":"practica/orquestation/#configurar-worker","text":"Clonar la vm restante como worker Configurarle 2 CPUs Configurar iptables Configurar el Container Runtime Instalar Kubeadm Configurar el cgroup driver para usar systemd Disable Swap Configurar red y configurar el adaptador de red para que sea NAT Network con la red creada anteriormente Direccion IP: 10.0.2.11 Hostname: worker Ejecutar kubeadm config images pull Ejectuar kubeadm init phase preflight para validar la instalaci\u00f3n Apagar la VM Crear un Snapshot de la vm llamada kube","title":"Configurar Worker"},{"location":"practica/orquestation/#crear-cluster","text":"Prender las vms Verificar conexion de red entre el host y las vms Verificar conexion de red entre las vms Configurar el archivo host en las vms como en tu pc con el nombre k8s a la ip 10.0.2.10 En la vm master ejecutar kubeadm init con los parametros necesarios para llegar por el nombre k8s En la vm worker ejecutar kubeadm join con los parametros necesarios para llegar por el nombre k8s","title":"Crear Cluster"},{"location":"practica/orquestation/#verificacion","text":"Copiar el kubeconfig a la pc e intentar hacer consultas con kubectl Realizar consultas a la API directamente con curl, usando tokens y certificados","title":"Verificaci\u00f3n"},{"location":"practica/orquestation/#ejercicio-2","text":"Clonarse el siguiente repositorio: web-go Analizar el codigo y el Dockerfile Construir la imagen y pushearla a un repo propio en dockerhub Testear la imagen localmente con docker Generar los siguientes recursos necesarios para ejecutar esta servidor web en Kubernetes teniendo en cuenta lo siguiente: Los recursos tienen que estar en un namespace independiente Las variables de ambiente FOO y BAR deben ser montadas mediante ConfigMaps en el despliegue Las variables de ambiente SUPERSECRETUSER y SUPERSECRETPASS deben ser montadas mediante Secrets en el despliegue Deben haber al menos dos pods corriendo Se debe poder acceder a estos recursos por Ingress Teniendo en cuenta lo armado, duplicar los recursos teniendo en cuenta lo siguiente Los recursos tienen que estar en un namespace distinto al anterior Se debe poder acceder a los servicios de este namespace por un path distinto al anterior Modificar el archivo web.go agregando un nueva impresion por pantalla Construir la imagen y pushearla con un tag nuevo (ej. v2 ) Modificar los recursos necesarios para que kubernetes despliegue la nueva version.","title":"Ejercicio 2"},{"location":"practica/virtualization/","text":"Virtualizaci\u00f3n Ejercicio 1 - Creaci\u00f3n Maquina Virtual ubuntu Crear una m\u00e1quina virtual con las siguientes caracter\u00edsticas. Nombre: ubuntu CPU: 2 cores RAM: 2 GB Disco: 20 GB Formato VDI Dinamicamente alocado Red: NAT SO: Ubuntu 20.04 LTS Iniciar la maquina virtual y realizar las siguientes tareas Instalar el sistema operativo Ubuntu 20.04 LTS Usar particionado estandar (no LVM) Durante la instalaci\u00f3n crear el usuario devops Usar las minimas configuraciones de instalaci\u00f3n Instalar Servidor SSH Aplicar las \u00faltimas actualizaciones disponibles Apagar la maquina virtual Crear una instantanea de la maquina virtual llamada init Maquina Virtual centos Crear una nueva m\u00e1quina virtual con las siguientes caracter\u00edsticas. Nombre: centos CPU: 2 cores RAM: 2 GB Disco: 20 GB Formato VDI Dinamicamente alocado Red: NAT SO: CentOS 7 Iniciar la maquina virtual y realizar las siguientes tareas Instalar el sistema operativo CentOS 7 Usar LVM durante el particionado Durante la instalacion crear el usuario devops Usar las minimas configuraciones de instalaci\u00f3n Aplicarle las ultimas actualizaciones disponibles Apagar la maquina virtual Crear una instantanea de la maquina virtual llamada init Ejercicio 2 - Paquetes Maquina Virtual ubuntu Instalar docker usando la siguiente gu\u00eda Instalar utilizando el repositorio comunitario oficial Apagar la maquina virtual y realizar una instantanea con nombre containers Instalar Nginx utilizando los repos oficiales usando la siguiente gu\u00eda Habilitar y arrancar el servicio de nginx Realizar una consulta simple al servicio con curl desde el host Apagar la maquina y restaurar la instantanea containers creando una instantanea llamada packages para almacenar el trabajo hecho. Maquina Virtual centos Instalar podman usando la siguiente gu\u00eda Instalar utilizando el repositorio comunitario oficial Instalar CRI-O version 1.20 usando la siguiente gu\u00eda Apagar la maquina virtual y realizar una instantanea con nombre containers Instalar HAProxy utilizando el repositorio los paquetes preconstruidos del sistema operativo Habilitar y arrancar el servicio de HAProxy Realizar una consulta simple al servicio con curl desde el host Apagar la maquina y restaurar la instantanea containers creando una instantanea llamada packages para almacenar el trabajo hecho. Ejercicio 3 - Red Iniciar las maquinas virtuales centos y ubuntu NAT Realizar ping a internet Realizar ping al host Realizar ping a las otras maquinas virtuales Ingresar por ssh a las maquinas virtuales Intentar desde el host Intentar desde las maquinas virtualess a la otra Configurar port forwarding para poder ingresar por ssh desde el host Configurar el puerto 1022 para la maquina centos Configurar el puerto 1023 para la maquina ubuntu Bridge Adapter Conectar las maquinas virtuales a la red LAN local de tu casa Ingresar por ssh desde una maquina virtual hacia la otra Ingresar por ssh desde el host Net Host Adapter Configurar el Net Host Adapter con la IP 10.0.2.1/24, deshabilitar DHCP Configurar direcciones IP estaticas en las m\u00e1quinas virtuales en el segmento anterior Ingresar por ssh desde una maquina virtual hacia la otra Ingresar por ssh desde el host Repetir con otro segmento de red Red NAT Crear una Red NAT llamada devops , con DHCP activado Conectar las maquinas virtuales a esta red NAT Ingresar por ssh desde una maquina virtual hacia la otra Ingresar por ssh desde el host usando port forwarding Deshabilitar DHCP en la Red NAT Configurar direcciones IPs est\u00e1ticas en las maquinas virtuales. Ingresar por ssh desde una maquina virtual hacia la otra Ingresar por ssh desde el host usando port forwarding Apagar la maquina y crear instantantea con el nombre network Ejercicio 4 - Almacenamiento Maquina Virtual ubuntu Con la maquina apagada agregar un nuevo disco de 2 GB Iniciar la maquina y realizar las siguientes tareas Ubicar el nuevo dispositivo agregado ( /dev ) Crear una nueva particion dentro del dispositivo Formatear la nueva particion con formato ext4 Montar el nuevo file system en /home/devops/storage , y que permanezca durante reinicios. Apagar la maquina y restaurar la instantanea network creando una instantanea llamada storage para almacenar el trabajo hecho. Maquina Virtual centos Con la maquina apagada agregar un 2 discos nuevos de 2 GB cada uno Iniciar la maquina y realizar las siguientes tareas Ubicar los nuevos dispositivos agregados ( /dev ) Crear una nueva particion dentro de cada dispositivo Crear un pv (physical volume) a partir de las nuevas particiones Crear un nuevo vg (volume group) con nombre devops y a\u00f1adir los ultimos dos pv Crear un lv dentro del vg devops con nombre storage usando todo el espacio disponible Formatear el nuevo lv con formate xfs Montar el nuevo file system en /home/devops/storage , y que permanezca durante reinicios. Apagar la maquina y restaurar la instantanea network creando una instantanea llamada storage para almacenar el trabajo hecho. Ejercicio 5 - Usuarios Maquina Virtual ubuntu Crear el usuario ubuntu y el usuario guest , asignarle una contrase\u00f1a a cada uno Crear el grupo frre Agregar el usuario ubuntu al grupo frre Crear el archivo test-user-permission.txt y darle permisos exclusivos de lectura, escritura y ejecucion al usuario ubuntu Intentar acceder a este archivo como el usuario guest Crear el archivo test-group-permission.txt y darle permisos exclusivos de lectura, escritura y ejecucion al group frre Intentar acceder a este archivo como el usuario guest y con el usuario ubuntu Apagar la maquina y restaurar la instantanea network creando una instantanea llamada users para almacenar el trabajo hecho. Maquina Virtual centos Crear el usuario centos y el usuario guest , asignarle una contrase\u00f1a a cada uno Crear el grupo frre Agregar el usuario centos al grupo frre Crear el archivo test-user-permission.txt y darle permisos exclusivos de lectura, escritura y ejecucion al usuario centos Intentar acceder a este archivo como el usuario guest Crear el archivo test-group-permission.txt y darle permisos exclusivos de lectura, escritura y ejecucion al group frre Intentar acceder a este archivo como el usuario guest y con el usuario centos Apagar la maquina y restaurar la instantanea network creando una instantanea llamada users para almacenar el trabajo hecho. Ejercicio 6 - SSH Maquina Virtual ubuntu Crear una clave ssh para el usuario ubuntu Autorizar la clave publica generada para el usuario centos en la maquina virtual centos Ingresar por ssh con el usuario centos a la maquina virtual centos a traves de la clave generada Repetir las pruebas de permisos del ejercicio anterior Apagar la maquina y restaurar la instantanea network creando una instantanea llamada ssh para almacenar el trabajo hecho. Maquina Virtual centos Crear una clave ssh para el usuario centos Autorizar la clave publica generada para el usuario ubuntu en la maquina virtual ubuntu Ingresar por ssh con el usuario ubuntu a la maquina virtual ubuntu a traves de la clave generada Repetir las pruebas de permisos del ejercicio anterior Apagar la maquina y restaurar la instantanea network creando una instantanea llamada ssh para almacenar el trabajo hecho.","title":"Virtualizaci\u00f3n"},{"location":"practica/virtualization/#virtualizacion","text":"","title":"Virtualizaci\u00f3n"},{"location":"practica/virtualization/#ejercicio-1-creacion","text":"Maquina Virtual ubuntu Crear una m\u00e1quina virtual con las siguientes caracter\u00edsticas. Nombre: ubuntu CPU: 2 cores RAM: 2 GB Disco: 20 GB Formato VDI Dinamicamente alocado Red: NAT SO: Ubuntu 20.04 LTS Iniciar la maquina virtual y realizar las siguientes tareas Instalar el sistema operativo Ubuntu 20.04 LTS Usar particionado estandar (no LVM) Durante la instalaci\u00f3n crear el usuario devops Usar las minimas configuraciones de instalaci\u00f3n Instalar Servidor SSH Aplicar las \u00faltimas actualizaciones disponibles Apagar la maquina virtual Crear una instantanea de la maquina virtual llamada init Maquina Virtual centos Crear una nueva m\u00e1quina virtual con las siguientes caracter\u00edsticas. Nombre: centos CPU: 2 cores RAM: 2 GB Disco: 20 GB Formato VDI Dinamicamente alocado Red: NAT SO: CentOS 7 Iniciar la maquina virtual y realizar las siguientes tareas Instalar el sistema operativo CentOS 7 Usar LVM durante el particionado Durante la instalacion crear el usuario devops Usar las minimas configuraciones de instalaci\u00f3n Aplicarle las ultimas actualizaciones disponibles Apagar la maquina virtual Crear una instantanea de la maquina virtual llamada init","title":"Ejercicio 1 - Creaci\u00f3n"},{"location":"practica/virtualization/#ejercicio-2-paquetes","text":"Maquina Virtual ubuntu Instalar docker usando la siguiente gu\u00eda Instalar utilizando el repositorio comunitario oficial Apagar la maquina virtual y realizar una instantanea con nombre containers Instalar Nginx utilizando los repos oficiales usando la siguiente gu\u00eda Habilitar y arrancar el servicio de nginx Realizar una consulta simple al servicio con curl desde el host Apagar la maquina y restaurar la instantanea containers creando una instantanea llamada packages para almacenar el trabajo hecho. Maquina Virtual centos Instalar podman usando la siguiente gu\u00eda Instalar utilizando el repositorio comunitario oficial Instalar CRI-O version 1.20 usando la siguiente gu\u00eda Apagar la maquina virtual y realizar una instantanea con nombre containers Instalar HAProxy utilizando el repositorio los paquetes preconstruidos del sistema operativo Habilitar y arrancar el servicio de HAProxy Realizar una consulta simple al servicio con curl desde el host Apagar la maquina y restaurar la instantanea containers creando una instantanea llamada packages para almacenar el trabajo hecho.","title":"Ejercicio 2 - Paquetes"},{"location":"practica/virtualization/#ejercicio-3-red","text":"Iniciar las maquinas virtuales centos y ubuntu NAT Realizar ping a internet Realizar ping al host Realizar ping a las otras maquinas virtuales Ingresar por ssh a las maquinas virtuales Intentar desde el host Intentar desde las maquinas virtualess a la otra Configurar port forwarding para poder ingresar por ssh desde el host Configurar el puerto 1022 para la maquina centos Configurar el puerto 1023 para la maquina ubuntu Bridge Adapter Conectar las maquinas virtuales a la red LAN local de tu casa Ingresar por ssh desde una maquina virtual hacia la otra Ingresar por ssh desde el host Net Host Adapter Configurar el Net Host Adapter con la IP 10.0.2.1/24, deshabilitar DHCP Configurar direcciones IP estaticas en las m\u00e1quinas virtuales en el segmento anterior Ingresar por ssh desde una maquina virtual hacia la otra Ingresar por ssh desde el host Repetir con otro segmento de red Red NAT Crear una Red NAT llamada devops , con DHCP activado Conectar las maquinas virtuales a esta red NAT Ingresar por ssh desde una maquina virtual hacia la otra Ingresar por ssh desde el host usando port forwarding Deshabilitar DHCP en la Red NAT Configurar direcciones IPs est\u00e1ticas en las maquinas virtuales. Ingresar por ssh desde una maquina virtual hacia la otra Ingresar por ssh desde el host usando port forwarding Apagar la maquina y crear instantantea con el nombre network","title":"Ejercicio 3 - Red"},{"location":"practica/virtualization/#ejercicio-4-almacenamiento","text":"Maquina Virtual ubuntu Con la maquina apagada agregar un nuevo disco de 2 GB Iniciar la maquina y realizar las siguientes tareas Ubicar el nuevo dispositivo agregado ( /dev ) Crear una nueva particion dentro del dispositivo Formatear la nueva particion con formato ext4 Montar el nuevo file system en /home/devops/storage , y que permanezca durante reinicios. Apagar la maquina y restaurar la instantanea network creando una instantanea llamada storage para almacenar el trabajo hecho. Maquina Virtual centos Con la maquina apagada agregar un 2 discos nuevos de 2 GB cada uno Iniciar la maquina y realizar las siguientes tareas Ubicar los nuevos dispositivos agregados ( /dev ) Crear una nueva particion dentro de cada dispositivo Crear un pv (physical volume) a partir de las nuevas particiones Crear un nuevo vg (volume group) con nombre devops y a\u00f1adir los ultimos dos pv Crear un lv dentro del vg devops con nombre storage usando todo el espacio disponible Formatear el nuevo lv con formate xfs Montar el nuevo file system en /home/devops/storage , y que permanezca durante reinicios. Apagar la maquina y restaurar la instantanea network creando una instantanea llamada storage para almacenar el trabajo hecho.","title":"Ejercicio 4 - Almacenamiento"},{"location":"practica/virtualization/#ejercicio-5-usuarios","text":"Maquina Virtual ubuntu Crear el usuario ubuntu y el usuario guest , asignarle una contrase\u00f1a a cada uno Crear el grupo frre Agregar el usuario ubuntu al grupo frre Crear el archivo test-user-permission.txt y darle permisos exclusivos de lectura, escritura y ejecucion al usuario ubuntu Intentar acceder a este archivo como el usuario guest Crear el archivo test-group-permission.txt y darle permisos exclusivos de lectura, escritura y ejecucion al group frre Intentar acceder a este archivo como el usuario guest y con el usuario ubuntu Apagar la maquina y restaurar la instantanea network creando una instantanea llamada users para almacenar el trabajo hecho. Maquina Virtual centos Crear el usuario centos y el usuario guest , asignarle una contrase\u00f1a a cada uno Crear el grupo frre Agregar el usuario centos al grupo frre Crear el archivo test-user-permission.txt y darle permisos exclusivos de lectura, escritura y ejecucion al usuario centos Intentar acceder a este archivo como el usuario guest Crear el archivo test-group-permission.txt y darle permisos exclusivos de lectura, escritura y ejecucion al group frre Intentar acceder a este archivo como el usuario guest y con el usuario centos Apagar la maquina y restaurar la instantanea network creando una instantanea llamada users para almacenar el trabajo hecho.","title":"Ejercicio 5 - Usuarios"},{"location":"practica/virtualization/#ejercicio-6-ssh","text":"Maquina Virtual ubuntu Crear una clave ssh para el usuario ubuntu Autorizar la clave publica generada para el usuario centos en la maquina virtual centos Ingresar por ssh con el usuario centos a la maquina virtual centos a traves de la clave generada Repetir las pruebas de permisos del ejercicio anterior Apagar la maquina y restaurar la instantanea network creando una instantanea llamada ssh para almacenar el trabajo hecho. Maquina Virtual centos Crear una clave ssh para el usuario centos Autorizar la clave publica generada para el usuario ubuntu en la maquina virtual ubuntu Ingresar por ssh con el usuario ubuntu a la maquina virtual ubuntu a traves de la clave generada Repetir las pruebas de permisos del ejercicio anterior Apagar la maquina y restaurar la instantanea network creando una instantanea llamada ssh para almacenar el trabajo hecho.","title":"Ejercicio 6 - SSH"}]}